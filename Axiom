# Design Axioms

This repository follows a small set of non-negotiable axioms. These axioms exist to
prevent “helpful” tooling (including AI) from expanding scope, weakening security,
or introducing hidden authority.

If a change conflicts with an axiom, the change is rejected.

---

## Axiom 1 — Authority Is Explicit

No action with irreversible consequences may be performed implicitly.

Irreversible actions include (non-exhaustive):
- Deploying a contract / upgrading code
- Minting, increasing, or migrating supply
- Moving treasury or liquidity
- Changing governance keys or permissions

**Requirement:** Every irreversible action must be initiated by an explicit human
authorization step with a clear preview of consequences.

---

## Axiom 2 — Phones Authorize, Servers Execute

Mobile devices are treated as **authorization surfaces**, not execution environments.

- **Mobile:** choose parameters, review invariants, sign intent
- **Server/Codespaces/CI:** execute deterministic validation and deployment
- **Chain:** final arbiter of state

**Forbidden:** claims or implementations that depend on “mobile terminal parity”
or “compile/deploy directly from iPhone/Android” as a primary path.

---

## Axiom 3 — Invariants Gate Reality

A system is not “safe” because it is documented. It is safe because invalid states
cannot be reached.

**Requirement:** Before deployment (and before any privileged action), configs and
operations must pass invariant checks.

Examples (project-dependent):
- Fixed supply cannot increase
- Burn caps cannot be exceeded
- Timelocks cannot be shortened or bypassed
- Module combinations must not create privilege escalation paths

---

## Axiom 4 — Configuration, Not Custom Code Per Token

New assets should be created by providing configuration to pre-audited artifacts
(templates/factories/modules), not by writing new bespoke contract logic each time.

**Goal:** minimize surface area and maximize repeatability.

---

## Axiom 5 — Determinism Over Convenience

Repeatable builds and verifiable artifacts are preferred over convenience features.

**Requirement:** Artifacts must be hash-identifiable and reproducible.
Where possible:
- record artifact hashes
- record config digests
- record deployment receipts

---

## Axiom 6 — No Hidden Admin Escape Hatches

If the system requires “trust me” for safety, the system is not safe.

**Forbidden (unless explicitly documented and justified):**
- upgrade keys that can bypass invariants
- privileged methods that alter supply without hard constraints
- emergency controls without a published threat model and scope

---

## Axiom 7 — Key Custody Is a First-Class Design Problem

Deployment and privileged actions require keys. Key handling must be intentional.

**Allowed approaches (prefer earlier items):**
1. Ephemeral session keys, tightly scoped
2. Limited-access keys with explicit allowances + method allowlists
3. Hardware-backed signing
4. Multi-sig governance wrapper (for production)

**Forbidden:**
- committing keys
- printing secrets to logs
- encouraging users to paste root keys into workflows

---

## Axiom 8 — Ceremony Produces Receipts

Every critical action should produce durable receipts:
- who authorized it
- what config was used (digest)
- what artifact was executed (hash)
- what network/account it targeted
- what transaction results occurred

Receipts are not optional. They are the audit trail.

---

## Axiom 9 — Scope Is Constrained By Non-Goals

A “complete” system is not one that does everything.
It is one that refuses to do unsafe or unbounded things.

**Requirement:** Every major feature set must include explicit non-goals.

---

## Axiom 10 — AI Output Is Draft Until Proven

AI can propose text and code, but it cannot be the final authority.

**Requirement:** AI-authored changes must be reviewed for:
- invariant violations
- key custody risks
- accidental automation
- claims of capabilities that are not true (esp. mobile execution)

---

## Practical Rule for Contributors (Human or AI)

When adding features, follow this order:

1. Define the config/schema
2. Define invariants (what must never be false)
3. Implement validation (deterministic)
4. Implement execution runner (controlled, no secrets)
5. Add receipts + documentation

Any PR that skips steps 1–3 is rejected.
